{"version":3,"file":"three-buffer-vertex-data.modern.js","sources":["../node_modules/dtype/index.js","../node_modules/flatten-vertex-data/index.js","../index.js"],"sourcesContent":["module.exports = function(dtype) {\n  switch (dtype) {\n    case 'int8':\n      return Int8Array\n    case 'int16':\n      return Int16Array\n    case 'int32':\n      return Int32Array\n    case 'uint8':\n      return Uint8Array\n    case 'uint16':\n      return Uint16Array\n    case 'uint32':\n      return Uint32Array\n    case 'float32':\n      return Float32Array\n    case 'float64':\n      return Float64Array\n    case 'array':\n      return Array\n    case 'uint8_clamped':\n      return Uint8ClampedArray\n  }\n}\n","/*eslint new-cap:0*/\nvar dtype = require('dtype')\n\nmodule.exports = flattenVertexData\n\nfunction flattenVertexData (data, output, offset) {\n  if (!data) throw new TypeError('must specify data as first parameter')\n  offset = +(offset || 0) | 0\n\n  if (Array.isArray(data) && (data[0] && typeof data[0][0] === 'number')) {\n    var dim = data[0].length\n    var length = data.length * dim\n    var i, j, k, l\n\n    // no output specified, create a new typed array\n    if (!output || typeof output === 'string') {\n      output = new (dtype(output || 'float32'))(length + offset)\n    }\n\n    var dstLength = output.length - offset\n    if (length !== dstLength) {\n      throw new Error('source length ' + length + ' (' + dim + 'x' + data.length + ')' +\n        ' does not match destination length ' + dstLength)\n    }\n\n    for (i = 0, k = offset; i < data.length; i++) {\n      for (j = 0; j < dim; j++) {\n        output[k++] = data[i][j] === null ? NaN : data[i][j]\n      }\n    }\n  } else {\n    if (!output || typeof output === 'string') {\n      // no output, create a new one\n      var Ctor = dtype(output || 'float32')\n\n      // handle arrays separately due to possible nulls\n      if (Array.isArray(data) || output === 'array') {\n        output = new Ctor(data.length + offset)\n        for (i = 0, k = offset, l = output.length; k < l; k++, i++) {\n          output[k] = data[i] === null ? NaN : data[i]\n        }\n      } else {\n        if (offset === 0) {\n          output = new Ctor(data)\n        } else {\n          output = new Ctor(data.length + offset)\n\n          output.set(data, offset)\n        }\n      }\n    } else {\n      // store output in existing array\n      output.set(data, offset)\n    }\n  }\n\n  return output\n}\n","import flatten from 'flatten-vertex-data'\nimport { BufferAttribute } from 'three'\n\nfunction setIndex (geometry, data, itemSize, dtype) {\n  if (typeof itemSize !== 'number') itemSize = 1\n  if (typeof dtype !== 'string') dtype = 'uint16'\n\n  const attrib = updateAttribute(data, itemSize, dtype)\n  if (attrib) {\n    if (!geometry.index && typeof geometry.setIndex !== 'function') {\n      geometry.addAttribute('index', attrib)\n    } else {\n      geometry.index = attrib\n    }\n  }\n}\n\nfunction setAttribute (geometry, key, data, itemSize, dtype) {\n  if (typeof itemSize !== 'number') itemSize = 3\n  if (typeof dtype !== 'string') dtype = 'float32'\n  if (Array.isArray(data) &&\n    Array.isArray(data[0]) &&\n    data[0].length !== itemSize) {\n    throw new Error('Nested vertex array has unexpected size; expected ' +\n      itemSize + ' but found ' + data[0].length)\n  }\n\n  const attrib = updateAttribute(data, itemSize, dtype)\n  geometry.setAttribute(key, attrib)\n}\n\nfunction updateAttribute (data, itemSize, dtype) {\n  data = data || []\n\n  // create a new array with desired type\n  data = flatten(data, dtype)\n\n  const attrib = new BufferAttribute(data, itemSize);\n  attrib.itemSize = itemSize;\n  attrib.needsUpdate = true;\n\n  return attrib\n}\n\nexport { setIndex as index, setAttribute as attr }\n"],"names":["dtype","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Array","Uint8ClampedArray","data","output","offset","TypeError","isArray","i","j","k","l","dim","length","dstLength","Error","NaN","set","Ctor","setIndex","geometry","itemSize","attrib","updateAttribute","index","addAttribute","setAttribute","key","flatten","BufferAttribute","needsUpdate"],"mappings":"wCAAA,MAAiB,SAASA,GACxB,OAAQA,GACN,IAAK,OACH,OAAOC,UACT,IAAK,QACH,OAAOC,WACT,IAAK,QACH,OAAOC,WACT,IAAK,QACH,OAAOC,WACT,IAAK,SACH,OAAOC,YACT,IAAK,SACH,OAAOC,YACT,IAAK,UACH,OAAOC,aACT,IAAK,UACH,OAAOC,aACT,IAAK,QACH,OAAOC,MACT,IAAK,gBACH,OAAOC,sBChBb,SAA4BC,EAAMC,EAAQC,GACxC,IAAKF,EAAM,MAAM,IAAIG,UAAU,wCAG/B,GAFAD,EAA0B,IAAfA,GAAU,GAEjBJ,MAAMM,QAAQJ,IAAUA,EAAK,IAA4B,iBAAfA,EAAK,GAAG,GAAkB,CACtE,IAEIK,EAAGC,EAAGC,EAAGC,EAFTC,EAAMT,EAAK,GAAGU,OACdA,EAASV,EAAKU,OAASD,EAItBR,GAA4B,iBAAXA,IACpBA,EAAS,IAAKZ,EAAMY,GAAU,WAArB,CAAiCS,EAASR,IAGrD,IAAIS,EAAYV,EAAOS,OAASR,EAChC,GAAIQ,IAAWC,EACb,MAAM,IAAIC,MAAM,iBAAmBF,EAAS,KAAOD,EAAM,IAAMT,EAAKU,OAApD,uCAC0BC,GAG5C,IAAKN,EAAI,EAAGE,EAAIL,EAAQG,EAAIL,EAAKU,OAAQL,IACvC,IAAKC,EAAI,EAAGA,EAAIG,EAAKH,IACnBL,EAAOM,KAAsB,OAAfP,EAAKK,GAAGC,GAAcO,IAAMb,EAAKK,GAAGC,QAItD,GAAKL,GAA4B,iBAAXA,EAqBpBA,EAAOa,IAAId,EAAME,OArBwB,CAEzC,IAAIa,EAAO1B,EAAMY,GAAU,WAG3B,GAAIH,MAAMM,QAAQJ,IAAoB,UAAXC,EAEzB,IAAKI,EAAI,EAAGE,EAAIL,EAAQM,GADxBP,EAAS,IAAIc,EAAKf,EAAKU,OAASR,IACGQ,OAAQH,EAAIC,EAAGD,IAAKF,IACrDJ,EAAOM,GAAiB,OAAZP,EAAKK,GAAcQ,IAAMb,EAAKK,QAG7B,IAAXH,EACFD,EAAS,IAAIc,EAAKf,IAElBC,EAAS,IAAIc,EAAKf,EAAKU,OAASR,IAEzBY,IAAId,EAAME,GASzB,OAAOD,GCrDT,SAASe,EAAUC,EAAUjB,EAAMkB,EAAU7B,GACnB,iBAAb6B,IAAuBA,EAAW,GACxB,iBAAV7B,IAAoBA,EAAQ,UAEvC,MAAM8B,EAASC,EAAgBpB,EAAMkB,EAAU7B,GAC3C8B,IACGF,EAASI,OAAsC,mBAAtBJ,EAASD,SAGrCC,EAASI,MAAQF,EAFjBF,EAASK,aAAa,QAASH,IAOrC,SAASI,EAAcN,EAAUO,EAAKxB,EAAMkB,EAAU7B,GAGpD,GAFwB,iBAAb6B,IAAuBA,EAAW,GACxB,iBAAV7B,IAAoBA,EAAQ,WACnCS,MAAMM,QAAQJ,IAChBF,MAAMM,QAAQJ,EAAK,KACnBA,EAAK,GAAGU,SAAWQ,EACnB,UAAUN,MAAM,qDACdM,EAAW,cAAgBlB,EAAK,GAAGU,QAGvC,MAAMS,EAASC,EAAgBpB,EAAMkB,EAAU7B,GAC/C4B,EAASM,aAAaC,EAAKL,GAG7B,SAASC,EAAiBpB,EAAMkB,EAAU7B,GAIxCW,EAAOyB,EAHPzB,EAAOA,GAAQ,GAGMX,GAErB,MAAM8B,EAAS,IAAIO,EAAgB1B,EAAMkB,GAIzC,OAHAC,EAAOD,SAAWA,EAClBC,EAAOQ,aAAc,EAEdR"}